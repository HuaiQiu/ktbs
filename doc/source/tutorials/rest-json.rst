.. _ktbs-rest-json-tutorial:

Using kTBS with REST and JSON
=============================

This tutorial aims at showing how to create :ref:`kTBS elements <restful-api>`
directly through the REST_ API with JSON_ descriptions.
If you are familiar with Turtle or RDF_, you might prefer
the :ref:`Turtle <ktbs-rest-turtle-tutorial>` version of that tutorial.

.. _REST: http://en.wikipedia.org/wiki/Representational_state_transfer
.. _JSON: http://json.org/
.. _RDF: http://www.w3.org/RDF/


Tools
+++++

For interacting with the kTBS, we will use the simple HTTP client that is
embeded within every HTML page generated by kTBS.
To use it, just click on the ``edit`` button at the lower left of the page.

Don't forget, though, that this embeded client is only a convenience shortcut
for easily interacting with kTBS.
You can just as well use any HTTP client,
either interactive (such as `curl <http://curl.haxx.se/>`_)
or programmatic.

Note also that the JSON code displayed by the editor
might differ from the one presented in those examples,
for example in the order of the properties.
However, they represent the same data.



Create and populate a Stored Trace
++++++++++++++++++++++++++++++++++

In this first part, we will create and populate a stored trace.
But for this, we first need to create a Base that will host our traces.

The kTBS Root
-------------

The kTBS root is where all bases live.
It is automatically created when the kTBS is first launched.
Its URI is that of the kTBS server, in our case: http://localhost:8001/ .

Create a new base
-----------------

To create a new base in our kTBS root,
we have to perform an HTTP POST request to it.

Visit the `kTBS root <http://localhost:8001>`_
and open the embeded HTTP client
by clicking to ``edit`` at the lower-left of the page.

In the HTTP client text-area,
we will provide a description of the base to be created,
which should look as follows:

.. code-block:: json

    {
        "@id": "base1/",
        "@type": "Base",
        "label": "My new base"
    }


then ensure that the content-type ``application/json`` is selected,
finally press the ``POST`` button.

You should be redirected to http://localhost:8001/base1/,
which is the URI of your newly created base,
and displays a description of your base.

If you open the editor again,
you will see the JSON description of the base we just created.
You will notice that, besides the properties that you set when posting,
the kTBS created two other properties, ``@context`` and ``inRoot``.
The latter links the base to the kTBS root it belongs to.
We will explain the ``@context`` property later in this tutorial.


.. note::

   A number of JSON properties expect URIs,
   as for example ``@id`` or ``inBase``.
   In the example above,
   all URIs are relative to the URI of the resource *to which we post it*;
   for example:

   * ``base1/`` is interpreted as ``http://localhost:8001/base1/``;

   this rule is true for all POST and PUT requests to the kTBS.



Create a stored trace
---------------------

Creating a stored trace inside a base
is very similar to creating a base in the kTBS root.
We first need to visit the `base <http://localhost:8001/base1/>`_
(you should already be there after the previous step).

In the HTTP client text-area,
we will provide a description of the stored trace to be created,
which should look like:

.. code-block:: json

    {
        "@id": "t01/",
        "@type": "StoredTrace",
        "hasModel": "http://liris.cnrs.fr/silex/2011/simple-trace-model/",
        "origin": "1970-01-01T00:00:00Z"
    }


As previously, ensure that the selected content-type is ``application/json``,
then press the ``POST`` button.
Again, you should be redirected to the newly created trace.

By opening the editor to see the JSON description again,
you will notice that, besides the properties that you set for the new trace,
the kTBS created three other properties:

  * ``@context`` (which we will explain later, be patient),
  * ``inBase`` linking to the base containing this trace, and
  * ``hasObselList`` pointing to http://localhost:8001/base1/t01/@obsels.
    This is where all the obsels that we are going to add to this trace
    will be created.


Add obsels to trace
-------------------

Adding an obsel to a trace should be no surprise to you at this point:
it is simply done by POSTing a description of the obsel to the trace itself.

Simply visit `the trace <http://localhost:8001/base1/t01/>`_
and POST the following content to it:

.. code-block:: json

    {
        "@id": "obs1",
        "@type": "m:SimpleObsel"
    }

Note that ``m:SimpleObsel`` is a so-called compact URI,
where the prefix ``m:`` stands for the URI of the model of the trace.
So the type of the obsel is actually
http://liris.cnrs.fr/silex/2011/simple-trace-model/ .


Being redirected to the description of the new obsel,
open the editor.
You will notice that this time the kTBS added a number of properties
in addition to the ones you specified above.
More precisely:

  * The ``begin`` and ``end`` of the obsel have been automatically set
    based on the moment you posted the obsel;
    this is expressed in milliseconds since the origin of the trace.

  * The ``hasTrace`` links the obsel to the trace containing it.

  * The ``@context`` property.
    
It would have been possible to specify some of those properties explicitly,
if we wanted to override the values automatically computed by the kbBS.

For example, let's go back to `the trace <http://localhost:8001/base1/t01/>`_
and POST the following content to it:

.. code-block:: json


    {
        "@id": "obs0",
        "@type": "m:SimpleObsel",
        "begin": 1361462605000,
        "end":   1361462647000
    }

We also note that, as with the base and the trace earlier,
we had to mint a URI for our new obsels.
As we are likely to create a large number of obsels,
it sounds like a good idea to leave it to the kTBS
to mint a fresh URI for each of them.
For our third obsel,
we will therefore use a `blank node <http://www.w3.org/TR/rdf-concepts/#section-blank-nodes>`_.
We will also add attributes and relations to our new obsel
to make it more interesting.

Let's go back to `the trace <http://localhost:8001/base1/t01/>`_
and POST the following content to it:

.. code-block:: json

    {
        "@type": "m:SimpleObsel",
        "m:value": "a new obsel",
        "m:hasRelatedObsel": { "@id": "obs1" }
    }


.. note::

   Every element of the kTBS can be created with a blank node instead of
   an explicit URI.
   The minted URI is always returned by the kTBS
   in the ``Location`` HTTP header.


If we follow the `hasObselCollection <http://liris.cnrs.fr/silex/2009/ktbs#hasObselCollection>`_ link from `our trace <http://localhost:8001/base1/t01/>`_,
to the `obsel collection`__,
we can see the three obsels we have created so far
(your timestamps will obviously differ):

__ http://localhost:8001/base1/t01/@obsels

.. code-block:: json

    {
    
        "@context": [
            "http://liris.cnrs.fr/silex/2011/ktbs-jsonld-context",
            { "m": "http://liris.cnrs.fr/silex/2011/simple-trace-model/" }
        ],
        "@id": "./",
        "hasObselList": {"@id":"", "@type": "StoredTraceObsels" },
        "obsels": [
            {
                "@id": "obs0",
                "@type": "m:SimpleObsel",
                "begin": 1361462605000,
                "end": 1361462647000
            },
            {
                "@id": "obs1",
                "@type": "m:SimpleObsel",
                "begin": 1394791006055,
                "end": 1394791006055,
                "@reverse": {
                    "m:hasRelatedObsel": {"hasTrace": "./", "@id": "o-8g"}
                }
            },
            {
                "@id": "o-8g",
                "@type": "m:SimpleObsel",
                "begin": 1394791489228,
                "end": 1394791489228,
                "m:hasRelatedObsel": {"hasTrace": "./", "@id": "obs1"},
                "m:value": "a new obsel"
            }
        ]
    }


Creating computed traces
++++++++++++++++++++++++

The kTBS has a number of :doc:`builtin methods <../concepts/method>`
to create Computed Traces.
As their name implies, computed trace differ from stored trace by the fact that
their obsels are *computed* by the kTBS
(in application of the corresponding method)
rather than provided by external collectors.


Create a Computed Trace with a filter method
--------------------------------------------

Let's go back to the `base <http://localhost:8001/base1/>`_
and create a new computed trace by POSTing the following:

.. code-block:: json

    {
        "@id": "filtered1/",
        "@type": "ComputedTrace",
        "hasMethod": "filter",
        "hasSource": [ "t01/" ],
        "parameter": [ "after=1361462641000" ]
    }

This create a computed trace named ``filtered1``
based on a *temporal filter*
which copies the obsels from ``t01`` obsels
situated *after* timestamp 1361462641000.
You may notice that we did not provide
any model nor origin for the computed trace;
those are automatically computed.

If you go and check the `obsel collection`__ of this computed trace,
you will find two obsels.
More precisely, all obsels from ``t01`` have been copied,
except for ``obs0`` which has been filtered out,
as it is not entierly after timestamp 1361462641000.

__ http://localhost:8001/base1/filtered1/@obsels

Create a Computed Trace with a SPARQL query
-------------------------------------------

We will now define a more sophisticated computed trace,
using the powerful query language
`SPARQL <http://www.w3.org/TR/rdf-sparql-query/>`_.

Let's go back to the `base <http://localhost:8001/base1/>`_
and create a new computed trace by POSTing the following:

.. code-block:: json

    {
        "@id": "joinRelated1/",
        "@type": "ComputedTrace",
        "hasMethod": "sparql",
        "hasSource": [ "t01/" ],
        "parameter": [ "sparql=    PREFIX : <http://liris.cnrs.fr/silex/2009/ktbs#>\nPREFIX m:  <http://liris.cnrs.fr/silex/2011/simple-trace-model/>\n\nCONSTRUCT {\n    [ a m:SimpleObsel ;\n      m:value ?value ;\n      :hasTrace <%(__destination__)s> ;\n      :hasBegin ?begin ;\n      :hasEnd ?end ;\n      :hasSourceObsel ?o1, ?o2 ;\n    ] .\n} WHERE {\n    ?o1 :hasBegin ?begin .\n    ?o2 :hasEnd ?end ;\n        m:hasRelatedObsel ?o1 .\n    OPTIONAL { ?o2 m:value ?value }\n}\n" ]
    }

This create a computed trace named ``joinRelated1``
using a SPARQL construct query
to builds an obsel for each pair of related obsels in ``t01``,
inheriting its ``begin`` and ``end`` timestamps respectively from each of them.

As the SPARQL query is not very legible when encoded as a JSON string,
it is provided below:

.. code-block:: sparql

    PREFIX : <http://liris.cnrs.fr/silex/2009/ktbs#>
    PREFIX m:  <http://liris.cnrs.fr/silex/2011/simple-trace-model/>

    CONSTRUCT {
        [ a m:SimpleObsel ;
          m:value ?value ;
          :hasTrace <%(__destination__)s> ;
          :hasBegin ?begin ;
          :hasEnd ?end ;
          :hasSourceObsel ?o1, ?o2 ;
        ] .
    } WHERE {
        ?o1 :hasBegin ?begin .
        ?o2 :hasEnd ?end ;
            m:hasRelatedObsel ?o1 .
        OPTIONAL { ?o2 m:value ?value }
    }


.. note::

   It is frequent that SPARQL construct queries build obsels that comply
   with a model different from the source trace's.
   The target model can be specified with the special ``model`` parameter
   supported by the :doc:`sparql method <../concepts/method>`.


Create a Computed Trace with a fusion method
--------------------------------------------

We will now use the ``fusion`` method,
used to aggregate in a computed trace
the obsels from several source traces.

Let's go back to the `base <http://localhost:8001/base1/>`_
and create a new computed trace by POSTing the following:

.. code-block:: json

    {
        "@id": "fusioned1/",
        "@type": "ComputedTrace",
        "hasMethod": "fusion",
        "hasSource": [ "filtered1/", "joinRelated1/" ]
    }


This creates a computed trace named ``fusioned1`` which is
a merge of the ``filtered1`` and the ``joinRelated1`` traces.


So what about this ``@context`` thing?
++++++++++++++++++++++++++++++++++++++

Internally, kTBS uses RDF_ to represent its data.
The JSON representations are therefore converted to/from RDF data.
For this, kTBS uses a technology called JSON-LD_.
The ``@context`` property is JSON-LD specific,
and provides the additional information required for
the conversion to/from RDF.

It is worth noting that kTBS accepts both content types
``application/json`` (generic JSON) and
``application/ld+json`` (JSON-LD).
When posting ``application/json``, you may omit the ``@context`` property
(as well as other properties, such as ``inRoot``, ``inBase`` and ``inTrace``),
as we have done along this tutorial,
but your JSON has to comply more closely to the structure expected by kTBS.
When posting ``application/json-ld``,
you are free to structure your JSON as you wish
as long as it translates into an RDF graph acceptable by kTBS;
this usually implies that you provide the ``@context`` property explicitly.

.. _JSON-LD: http://json-ld.org/
